function initial-expr chips
  expr = [{node: 0 id: 0, +operand, -operator, chip: chips.0, idx: 0}]
  n = 1
  for chip, i of chips.slice 1
    expr.push do
      {node: i + 1 , id: i + 1 , +operand, -operator, chip, idx: n++}
      {node: \H    , id: "op#i", -operand, +operator,       idx: n++}
  expr

# from postorder expr nodes to new tree
function tree-from expr
  nodes = expr.map -> {...it}
  stack = [nodes.shift!, nodes.shift!]
  while next = nodes.shift!
    if next.operator
      right = stack.pop!
      left  = stack.pop!
      next.children = [left, right]
    stack.push next

  return stack.0

function preorder
  order = []
  visit = ->
    order.push it
    if it.children then for that => visit &
  visit it
  return order

function postorder
  order = []
  visit = ->
    if it.children then for that => visit &
    order.push it
  visit it
  return order

# decorate postordered expr with d-numbers defined by
# section 4, last paragraph of the paper, for easy validity
# checking for move3
function d-number expr
  zeros = 0
  for expr
    zeros++ if &operator
    &d = zeros

complement      = H: \V V: \H
slice-direction = H: \width, V: \height
opposite        = width: \height height: \width
line-dimension  = width: \x height: \y
opp-dimension   = x: \y y: \x

# expand leaves to rectangles, and decorate nodes with size fitted to
# their children
function calculate-size root
  if root.children?
    left  = calculate-size root.children.0
    right = calculate-size root.children.1

    dir = slice-direction[root.node]
    opp = opposite[dir]

    fitted = Math.max left[dir], right[dir]

    # expand both children
    set-size left,  dir, fitted
    set-size right, dir, fitted

    # fitted along slice direction, summed in other
    root <<<
      (dir): fitted
      (opp): left[opp] + right[opp]
  else
    root <<< root.chip{width, height}

function set-size root, dir, value
  root[dir] = value
  if slice-direction[root.node] is dir and root.children
    set-size that.0, dir, value
    set-size that.1, dir, value

function flat-svg-layout layout, pos ? x: 0 y: 0
  rectangles = []
  slice-lines = []
  if layout.children
    [left, right] = layout.children

    dir = slice-direction[layout.node]
    opp = opposite[dir]

    line-dim = line-dimension[dir]
    line-opp = opp-dimension[line-dim]

    slice-lines.push layout <<<
      # stretches across group
      (line-dim + \1): pos[line-dim]
      (line-dim + \2): pos[line-dim] + layout[dir]

      # starting after left node
      (line-opp + \1): pos[line-opp] + left[opp]
      (line-opp + \2): pos[line-opp] + left[opp]

    left-layout = flat-svg-layout left, pos
    right-layout = flat-svg-layout right,
      (line-dim): pos[line-dim]
      (line-opp): pos[line-opp] + left[opp]

    rectangles.push ...left-layout.rectangles, ...right-layout.rectangles
    slice-lines.push ...left-layout.slice-lines, ...right-layout.slice-lines
  else
    rectangles.push layout <<<
      rect-x: pos.x
      rect-y: pos.y

  return {rectangles, slice-lines}
