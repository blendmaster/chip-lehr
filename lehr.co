var old-expr, expr
var layout-root, rect-root, line-root, tree-root, link-root, node-root, expr-root
var layout-border

# enter in all the d3 nodes, and transition to new state
!function display-layout
  # calculate d-numbers
  d-number expr

  # calculate and decorate layout tree
  layout = tree-from expr
  preordered  = preorder  layout
  postordered = postorder layout

  # decorate indices
  for n, i of postordered
    n.postorder = i
  for n, i of preordered
    n.preorder = i

  # slicing layout
  calculate-size layout
  expand-rects layout
  slicing-svg-layout = flat-svg-layout layout

  # fit layout to 300, 300
  max-dim = 10 * Math.max layout.width, layout.height
  scale = 300 / max-dim

  layout-root .transition!duration 750
    .attr \transform "scale(#scale)"

  layout-border .transition!duration 750 .attr do
    width: layout.width * 10
    height: layout.height * 10

  rectangles = rect-root.select-all \g.layout-area
    .data slicing-svg-layout.rectangles, -> it.id

  rectangles
    &enter!
      group = &append \svg:g .attr \class \layout-area
        .attr transform: ({rect-x, rect-y}) ->
          "translate(#{10 * rect-x}, #{10 * rect-y})"
      group
        &append \svg:rect .attr \class \layout-rect
          .attr do
            width: -> it.width * 10
            height: -> it.height * 10
        &append \svg:rect .attr \class \layout-chip
        &append \svg:text .attr \class \layout-text

    &transition!duration 750 .attr do
      transform: ({rect-x, rect-y}) ->
        "translate(#{10 * rect-x}, #{10 * rect-y})"

    &select \.layout-rect
      .attr \id -> "l#{it.preorder}"
      .transition!duration 750 .attr do
        width: -> it.width * 10
        height: -> it.height * 10

    &select \.layout-chip .transition!duration 750 .attr do
      width: -> it.chip.width * 10
      height: -> it.chip.height * 10
      x: -> (it.width * 10 - it.chip.width * 10) / 2
      y: -> (it.height * 10 - it.chip.height * 10) / 2

    &select \.layout-text
      .text -> it.node
      .transition!duration 750
      .style \font-size -> "#{Math.max 8, (Math.min 36, it.height * 10)}px"
      .attr do
        x: -> it.width * 10 / 2
        y: -> it.height * 10 / 2

  lines = line-root.select-all \line.layout-line
    .data slicing-svg-layout.slice-lines, -> it.id
  lines
    &enter!append \svg:line
      .attr \class \layout-line
    &attr do
      id: -> "l#{it.preorder}"
    &transition!duration 750
      .attr do
        x1: -> it.x1 * 10
        x2: -> it.x2 * 10
        y1: -> it.y1 * 10
        y2: -> it.y2 * 10

  # slicing tree
  tree = d3.layout.tree!size [400 400]
  nodes = tree.nodes layout
  links = tree.links nodes

  link = d3.svg.diagonal!

  link-nodes = link-root.select-all \path.link
    .data links, ->
      s = it.source.id
      t = it.target.id
      # keep ordering the same after transitions
      if s > t
        "#s#t"
      else
        "#t#s"
  link-nodes
    &exit!transition!duration 750
      .style \stroke-opacity 0
      .remove!
    &enter!append \svg:path .attr \class \link
      .style \stroke-opacity 0
    &transition!duration 750
      .attr \d link
      .style \stroke-opacity 1

  node-group = node-root.select-all \g.node
    .data nodes, -> it.id

  node-group.enter!
    g = &append \svg:g .attr do
      class: \node
      transform: 'translate(0,0)'
    g
      &append \svg:circle .attr do
        class : \node-dot
        r     : 20
      &append \svg:text
        .attr class: \node-text

  node-group.select \.node-text
    .text -> it.node

  node-group.transition!duration 750
    .attr \transform ({x, y}) -> "translate(#x, #y)"

  circles = node-group.select \.node-dot

  # draw polish expr
  expr-root.attr do
    width: expr.length * 50
    height: 100
  tokens = expr-root.select-all \.token .data postordered, -> it.id
  tokens
    &enter!
      g = &append \svg:g .attr \class \token
        .attr \transform 'translate(0,0)'
      g
        &append \svg:rect
          .attr do
            class: \token-rect
            width: 50
            height: 50
            x: -25
            y: -25
        &append \text
          .attr class: \token-text
    &select \.token-text
      .text -> it.node
    &transition!duration 750
      .attr do
        transform: (_, i) -> "translate(#{i * 50 + 25}, 50)"
      .each \end ->
        # highlight from expr, and clear existing highlight
        d3.select this
          .on \mouseover mouseover
          .on \mouseout  mouseout

  # setup synchronized highlighting

  highlight = (it, className, state)->
    d3.select tokens.0[it.idx] .classed className, state
    d3.select circles.0[it.preorder] .classed className, state
    d3.select "\#l#{it.preorder}"    .classed className, state

  # highlight node and its left and right subtree in both the tree and expression
  set-class = (state) -> ->
    highlight it, \hovered state
    if it.children
      highlight-tree that.0, \left-hovered state
      highlight-tree that.1, \right-hovered state

  highlight-tree = (root, className, state) ->
    highlight root, className, state
    if root.children
      highlight-tree that.0, className, state
      highlight-tree that.1, className, state

  mouseover = set-class true
  mouseout = !->
    d3.select-all \.hovered .classed \hovered false
    d3.select-all \.left-hovered .classed \left-hovered false
    d3.select-all \.right-hovered .classed \right-hovered false

  # highlight from graph
  node-group
    .on \mouseover mouseover
    .on \mouseout  mouseout

  # highlight from layout
  rectangles
    .on \mouseover mouseover
    .on \mouseout  mouseout
  lines
    .on \mouseover mouseover
    .on \mouseout  mouseout

  # Testing: make move1 on expr
  tokens.on \click !(node)->
    it = expr[node.idx]
    next = expr[it.idx + 1]
    # temporarily turn off mouse listeners
    tokens
      .on \mouseover null
      .on \mouseout  null

    if
      # move 1
      it.operand and next?operand
        new-expr = move.0 expr, it, next
      it.operator
        # if move 3 is possible, take it, else move2
        if next? and next?operand and valid expr, it, next
          new-expr = move.2 expr, it, next
        else
          last = expr[it.idx - 1]
          return unless last? and last.operand
          # for now, just complement as many as we can
          current = it.node
          len = 0
          for i from it.idx + 1 til expr.length
            if expr[i]operator and expr[i]node is not current
              current = expr[i]node
              len++
            else
              break

          new-expr = move.1 expr, it.idx, len
          console.log 'moving 2'
      it.operand
        # search ahead for next operator
        for i from it.idx + 1 til expr.length
          if expr[i]operand
            new-expr = move.0 expr, it, expr[i]

            break
    if new-expr?
      old-expr := expr
      expr := new-expr

      display-layout!
!function undo
  tmp = expr
  expr := old-expr
  old-expr := tmp

  console.log old-expr, tmp

  display-layout!

# SA moves, operating on slicing expression
move =
  # swap two adjacent operands
  * function move1 expr, operand1, operand2
      expr.map(-> {...it})
        tmp = &[operand1.idx]
        &[operand1.idx] = &[operand2.idx] <<< idx: operand1.idx
        &[operand2.idx] = tmp <<< idx: operand2.idx

  # complement some chain of non-zero length
  * function move2 expr, chain-start, len
      expr.map(-> {...it})
        for i from chain-start to chain-start + len
          &[i]node = complement[<>]

  # swap two adjacent operand and operator
  # WARNING: doesn't check for validity of the move
  * function move3 expr, alpha1, alpha2
      expr.map(-> {...it})
        tmp = &[alpha1.idx]
        &[alpha1.idx] = &[alpha2.idx] <<< idx: alpha1.idx
        &[alpha2.idx] = tmp <<< idx: alpha2.idx

# whether a move3 is valid
# section 4, last paragraph in the paper
function valid expr, alpha1, alpha2
  alpha3 = expr[alpha2.idx + 1]
  if alpha3? and alpha3.node is alpha1.node
    return false

  if alpha1.operand and alpha2.operator
    2 * alpha2.d < alpha1.idx # 2d_(i-1) < i
  else
    true

# annealing stuff
function cost layout
  # paper uses wire length manhattan distance, but to keep it simple
  # don't have any wires, just area
  layout.width * layout.height

# temperature schedule
const R = 0.85
function next-temperature old-temp
  R * old-temp

# enumerate all candidate
function choose-move expr
  candidates = []
  comp-len = 0
  for i til expr.length - 1
    # TODO operands not adjacent in regular expr, but in pi expr
    if expr[i]operand and expr[i + 1]operand
      candidates.push do
        move: 0
        args: [expr[i], expr[i + 1]]
    if expr[i]operator and expr[i]node is not last
      comp-start = i
      comp-len++
      last = expr[i]node
    if expr[i]operand
      if comp-len > 0
        for start from comp-start til comp-start + comp-len
          for len from 1 to comp-start + comp-len - start
            candidates.push do
              move: 1
              args: [start, len]
      last = void
      comp-len = 0
    if valid expr, expr[i], expr[i + 1]
      candidates.push do
        move: 2
        args: [expr[i], expr[i + 1]]

  # there is always a choice because of move 1
  return candidates[Math.floor Math.random! * candidates.length]

# TODO efficient area recalculation

const P = 0.95
function intial-temp layout
  # perform some random moves
  expr = postorder layout
  c = cost layout
  moves = for i til 100
    m = choose-move expr
    expr = move[m.move] expr, ...m.args

    layout = layout-from expr
    calculate-size layout

    new-c = cost layout

    if new-c > c
      new-c - c

  # compute the average of chance in cost in uphill moves.
  sum = moves.reduce (a, b) -> a + b
  avg = sum / moves.length

  # T = -avg / ln(P)
  return -avg / Math.log(P)

# section 7 in the paper
!function anneal layout
  temp = initial-temp layout

document.add-event-listener \DOMContentLoaded !->

  layout-root := d3.select \#slicing-rectangle
    .append \svg:svg .attr width: 300 height: 300
    .append \svg:g .attr \class \layout-container

  rect-root := layout-root
    .append \svg:g .attr \class \layout-rectangles

  layout-border := layout-root.append \svg:rect
    .attr id: \layout-border width: \100% height: \100%

  line-root := layout-root
    .append \svg:g .attr \class \layout-lines

  expr-root := d3.select \#polish-expression .append \svg:svg

  tree-root := d3.select \#slicing-tree
    .append \svg:svg .attr width: 500 height: 500
    .append \svg:g
      .attr do
        id        : \tree-root
        transform : 'translate(50, 50)'

  link-root := tree-root
    .append \svg:g
    .attr do
      id: \link-root

  node-root := tree-root
    .append \svg:g
    .attr do
      id: \node-root

  chips =
    * width: 10 height: 10
    * width:  6 height: 12
    * width:  3 height:  2
    * width:  5 height:  3
    * width:  5 height:  3
    * width:  5 height:  3

  expr := initial-expr chips

  display-layout!

  history = d3.select \#history

  document.get-element-by-id \undo .onclick = undo

