# width, height
chips =
  * width: 10 height: 10
  * width:  5 height: 12
  * width:  3 height:  2
  * width:  5 height:  3
  * width:  8 height:  8
  * width:  3 height:  5
  * width:  6 height:  6
  * width:  1 height:  1

# per section 7 in the paper, start with horizontal layout, recursively
function initial-layout chips, n = 0
  node: \H
  children:
    * node: n
      width: chips.0.width * 10
      height: chips.0.height * 10
      chip: chips.0
    * if chips.length is 2
        node:   n + 1
        width:  chips.1.width * 10
        height: chips.1.height * 10
        chip: chips.1
      else
        initial-layout chips.slice(1), n + 1

slicing-layout = initial-layout chips

# mix it up a little
op = H: \V V: \H
init = slicing-layout.node
current = slicing-layout
while current = current.children?1
  init = op[init]
  current.node = init unless current.node is not \H and current.node is not \V

SVGL = -> document.createElementNS \http://www.w3.org/2000/svg it

width = height = 500

slice-direction = H: \width, V: \height
opposite = width: \height height: \width
line-dimension = width: \x height: \y
opp-dimension = x: \y y: \x

# expand leaves to rectangles, and decorate branch nodes with size fitted to
# their children
function calculate-size layout
  if layout.children?
    left  = calculate-size layout.children.0
    right = calculate-size layout.children.1

    dir = slice-direction[layout.node]
    opp = opposite[dir]

    fitted = Math.max left[dir], right[dir]

    # expand both children
    set-size left,  dir, fitted
    set-size right, dir, fitted

    # fitted along slice direction, summed in other
    layout <<<
      (dir): fitted
      (opp): left[opp] + right[opp]
  else
    layout

function set-size layout, dir, value
  layout[dir] = value
  if slice-direction[layout.node] is dir and layout.children
    set-size that.0, dir, value
    set-size that.1, dir, value

slicing-layout = calculate-size slicing-layout

console.log slicing-layout

function flat-svg-layout layout, pos ? x: 0 y: 0
  rectangles = []
  slice-lines = []
  if layout.children
    [left, right] = layout.children

    dir = slice-direction[layout.node]
    opp = opposite[dir]

    line-dim = line-dimension[dir]
    line-opp = opp-dimension[line-dim]

    slice-lines.push layout <<<
      # stretches across group
      (line-dim + \1): pos[line-dim]
      (line-dim + \2): pos[line-dim] + layout[dir]

      # starting after left node
      (line-opp + \1): pos[line-opp] + left[opp]
      (line-opp + \2): pos[line-opp] + left[opp]

    left-layout = flat-svg-layout left, pos
    right-layout = flat-svg-layout right,
      (line-dim): pos[line-dim]
      (line-opp): pos[line-opp] + left[opp]

    rectangles.push ...left-layout.rectangles, ...right-layout.rectangles
    slice-lines.push ...left-layout.slice-lines, ...right-layout.slice-lines
  else
    rectangles.push layout <<<
      rect-x: pos.x
      rect-y: pos.y

  return {rectangles, slice-lines}

function preorder
  order = []
  visit = ->
    order.push it
    if it.children then for that => visit &
  visit it
  return order

function postorder
  order = []
  visit = ->
    if it.children then for that => visit &
    order.push it
  visit it
  return order

preordered  = preorder  slicing-layout
postordered = postorder slicing-layout

expr = postordered

# decorate indices
for n, i of postordered
  n.postorder = i
for n, i of preordered
  n.preorder = i

tree = d3.layout.tree!size [400 400]
nodes = tree.nodes slicing-layout
links = tree.links nodes

slicing-svg-layout = flat-svg-layout slicing-layout
console.log slicing-svg-layout

# adapted from http://blog.pixelingene.com/2011/07/building-a-tree-diagram-in-d3-js/
<-! document.add-event-listener \DOMContentLoaded

slicing-layout-root = d3.select \#slicing-rectangle
  .append \svg:svg .attr width: 250 height: 350

rectangles = slicing-layout-root
  .append \svg:g .attr \class \layout-rectangles
  .select-all \g.layout-rectangle-group
  .data slicing-svg-layout.rectangles .enter!
    .append \svg:g
      .attr do
        class: \layout-area
        transform: ({rect-x, rect-y}) -> "translate(#rect-x, #rect-y)"

rectangles
  &append \svg:rect
    .attr do
      id: -> "l#{it.preorder}"
      class: \layout-rect
      width: -> it.width
      height: -> it.height
  &append \svg:rect
    .attr do
      class: \layout-chip
      width: -> it.chip.width * 10
      height: -> it.chip.height * 10
      x: -> (it.width - it.chip.width * 10) / 2
      y: -> (it.height - it.chip.height * 10) / 2
  &append \svg:text
    .attr do
      class: \layout-text
      x: -> it.width / 2
      y: -> it.height / 2
    .text -> it.node

lines = slicing-layout-root
  .append \svg:g .attr \class \layout-lines
  .select-all \line.layout-line
  .data slicing-svg-layout.slice-lines .enter!
  .append \svg:line
    .attr do
      id: -> "l#{it.preorder}"
      class: \layout-line
      x1: -> it.x1
      x2: -> it.x2
      y1: -> it.y1
      y2: -> it.y2

layout-root = d3.select \#slicing-tree
  .append \svg:svg .attr width: 500 height: 500
  .append \svg:g
    .attr do
      class     : \container
      transform : 'translate(50, 50)'

link = d3.svg.diagonal!

layout-root.select-all \path.link
  .data links .enter!
  .append \svg:path
  .attr do
    class : \link
    d     : link

node-group = layout-root.select-all \g.node
  .data nodes .enter!
  .append \svg:g
  .attr do
    class     : \node
    transform : ({x, y}) -> "translate(#x, #y)"

circles = node-group.append \svg:circle
  .attr do
    class : \node-dot
    r     : 20

node-group.append \svg:text
  .attr class: \node-text
  .text -> it.node

# draw polish expr
expr-root = d3.select \#polish-expression .append \p

highlight = (it, className, state)->
  d3.select tokens.0[it.postorder] .classed className, state
  d3.select circles.0[it.preorder] .classed className, state
  d3.select "\#l#{it.preorder}"    .classed className, state

# highlight node and its left and right subtree in both the tree and expression
set-class = (state) -> ->
  highlight it, \hovered state
  if it.children
    highlight-tree that.0, \left-hovered state
    highlight-tree that.1, \right-hovered state

highlight-tree = (root, className, state) ->
  highlight root, className, state
  if root.children
    highlight-tree that.0, className, state
    highlight-tree that.1, className, state

mouseover = set-class true
mouseout = set-class false

tokens = expr-root.select-all \span.token
  .data expr .enter!
  .append \span
    .attr class: \token
    .text -> it.node
    .on \mouseover mouseover
    .on \mouseout  mouseout

# highlight tokens from graph
node-group
  .on \mouseover mouseover
  .on \mouseout  mouseout

# highlight from layout
rectangles
  .on \mouseover mouseover
  .on \mouseout  mouseout

for n, i of nodes
  let el = document.get-element-by-id "l#{n.preorder}"
    el.add-event-listener \mouseover ->
      mouseover.call this, n
    el.add-event-listener \mouseout ->
      mouseout.call this, n

