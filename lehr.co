# per section 7 in the paper, start with horizontal layout, recursively
function initial-layout chips, n = 0
  node: \H
  id: "operator#n"
  operand: false
  operator: true
  children:
    * if chips.length is 2
        node:   n + 1
        id: n + 1
        operand: true
        operator: false
        chip: chips.1
      else
        initial-layout chips.slice(1), n + 1
    * node: n
      id: n
      operand: true
      operator: false
      chip: chips.0

complement = H: \V V: \H
slice-direction = H: \width, V: \height
opposite = width: \height height: \width
line-dimension = width: \x height: \y
opp-dimension = x: \y y: \x

# expand leaves to rectangles, and decorate branch nodes with size fitted to
# their children
function calculate-size layout
  if layout.children?
    left  = calculate-size layout.children.0
    right = calculate-size layout.children.1

    dir = slice-direction[layout.node]
    opp = opposite[dir]

    fitted = Math.max left[dir], right[dir]

    # expand both children
    set-size left,  dir, fitted
    set-size right, dir, fitted

    # fitted along slice direction, summed in other
    layout <<<
      (dir): fitted
      (opp): left[opp] + right[opp]
  else
    layout <<< layout.chip{width, height}

function set-size layout, dir, value
  layout[dir] = value
  if slice-direction[layout.node] is dir and layout.children
    set-size that.0, dir, value
    set-size that.1, dir, value

function flat-svg-layout layout, pos ? x: 0 y: 0
  rectangles = []
  slice-lines = []
  if layout.children
    [left, right] = layout.children

    dir = slice-direction[layout.node]
    opp = opposite[dir]

    line-dim = line-dimension[dir]
    line-opp = opp-dimension[line-dim]

    slice-lines.push layout <<<
      # stretches across group
      (line-dim + \1): pos[line-dim]
      (line-dim + \2): pos[line-dim] + layout[dir]

      # starting after left node
      (line-opp + \1): pos[line-opp] + left[opp]
      (line-opp + \2): pos[line-opp] + left[opp]

    left-layout = flat-svg-layout left, pos
    right-layout = flat-svg-layout right,
      (line-dim): pos[line-dim]
      (line-opp): pos[line-opp] + left[opp]

    rectangles.push ...left-layout.rectangles, ...right-layout.rectangles
    slice-lines.push ...left-layout.slice-lines, ...right-layout.slice-lines
  else
    rectangles.push layout <<<
      rect-x: pos.x
      rect-y: pos.y

  return {rectangles, slice-lines}

function preorder
  order = []
  visit = ->
    order.push it
    if it.children then for that => visit &
  visit it
  return order

function postorder
  order = []
  visit = ->
    if it.children then for that => visit &
    order.push it
  visit it
  return order

# decorate postordered expr with d-numbers defined by
# section 4, last paragraph of the paper, for easy validity
# checking for move3
function d-number expr
  zeros = 0
  for expr
    zeros++ if &operator
    &d = zeros

# enter in all the d3 nodes, and transition to new state
!function display-layout layout, layout-root, rect-root, line-root, tree-root, \
                         link-root, node-root, expr-root
  # decorate layout tree
  preordered  = preorder  layout
  postordered = postorder layout
  d-number postordered
  # clean up d3 tree layout's parents
  for preordered
    delete &parent

  # decorate indices
  for n, i of postordered
    n.postorder = i
  for n, i of preordered
    n.preorder = i

  # slicing layout
  calculate-size layout
  slicing-svg-layout = flat-svg-layout layout

  # fit layout to 300, 300
  max-dim = 10 * Math.max layout.width, layout.height
  scale = 300 / max-dim

  layout-root .transition!duration 750 .attr \transform "scale(#scale)"

  rectangles = rect-root.select-all \g.layout-area
    .data slicing-svg-layout.rectangles, -> it.id

  rectangles
    &enter!
      group = &append \svg:g .attr \class \layout-area
        .attr \transform "translate(0,0)"
      group
        &append \svg:rect .attr \class \layout-rect
        &append \svg:rect .attr \class \layout-chip
        &append \svg:text .attr \class \layout-text

    &transition!duration 750 .attr do
      transform: ({rect-x, rect-y}) ->
        "translate(#{10 * rect-x}, #{10 * rect-y})"

    &select \.layout-rect
      .attr \id -> "l#{it.preorder}"
      .classed \left-hovered false
      .classed \right-hovered false
      .transition!duration 750 .attr do
        width: -> it.width * 10
        height: -> it.height * 10

    &select \.layout-chip .transition!duration 750 .attr do
      width: -> it.chip.width * 10
      height: -> it.chip.height * 10
      x: -> (it.width * 10 - it.chip.width * 10) / 2
      y: -> (it.height * 10 - it.chip.height * 10) / 2

    &select \.layout-text
      .text -> it.node
      .transition!duration 750
      .style \font-size -> "#{Math.max 8, (Math.min 36, it.height * 10)}px"
      .attr do
        x: -> it.width * 10 / 2
        y: -> it.height * 10 / 2

  lines = line-root.select-all \line.layout-line
    .data slicing-svg-layout.slice-lines, -> it.id
  lines
    &enter!append \svg:line
      .attr \class \layout-line
    &attr do
      id: -> "l#{it.preorder}"
    &transition!duration 750
      .attr do
        x1: -> it.x1 * 10
        x2: -> it.x2 * 10
        y1: -> it.y1 * 10
        y2: -> it.y2 * 10

  # slicing tree
  tree = d3.layout.tree!size [400 400]
  nodes = tree.nodes layout
  links = tree.links nodes

  link = d3.svg.diagonal!

  link-nodes = link-root.select-all \path.link
    .data links, ->
      s = it.source.id
      t = it.target.id
      # keep ordering the same after transitions
      if s > t
        "#s#t"
      else
        "#t#s"
  link-nodes
    &exit!transition!duration 750
      .style \stroke-opacity 0
      .remove!
    &enter!append \svg:path .attr \class \link
      .style \stroke-opacity 0
    &transition!duration 750
      .attr \d link
      .style \stroke-opacity 1

  node-group = node-root.select-all \g.node
    .data nodes, -> it.id

  node-group.enter!
    g = &append \svg:g .attr do
      class: \node
      transform: 'translate(0,0)'
    g
      &append \svg:circle .attr do
        class : \node-dot
        r     : 20
      &append \svg:text
        .attr class: \node-text

  node-group.select \.node-text
    .text -> it.node

  node-group.transition!duration 750
    .attr \transform ({x, y}) -> "translate(#x, #y)"

  circles = node-group.select \.node-dot
    .classed \left-hovered false
    .classed \right-hovered false

  # draw polish expr
  expr = postordered # handy
  expr-root.attr do
    width: postordered.length * 50
    height: 100
  tokens = expr-root.select-all \.token .data expr, -> it.id
  tokens
    &enter!
      g = &append \svg:g .attr \class \token
        .attr \transform 'translate(0,0)'
      g
        &append \svg:rect
          .attr do
            class: \token-rect
            width: 50
            height: 50
            x: -25
            y: -25
        &append \text
          .attr class: \token-text
    &select \.token-text
      .text -> it.node
    &classed \left-hovered false
    &classed \right-hovered false
    &transition!duration 750
      .attr do
        transform: (_, i) -> "translate(#{i * 50 + 25}, 50)"

  # setup synchronized highlighting

  highlight = (it, className, state)->
    d3.select tokens.0[it.postorder] .classed className, state
    d3.select circles.0[it.preorder] .classed className, state
    d3.select "\#l#{it.preorder}"    .classed className, state

  # highlight node and its left and right subtree in both the tree and expression
  set-class = (state) -> ->
    highlight it, \hovered state
    if it.children
      highlight-tree that.0, \left-hovered state
      highlight-tree that.1, \right-hovered state

  highlight-tree = (root, className, state) ->
    highlight root, className, state
    if root.children
      highlight-tree that.0, className, state
      highlight-tree that.1, className, state

  mouseover = set-class true
  mouseout = set-class false

  # highlight from expr, and clear existing highlight
  tokens
    .on \mouseover mouseover
    .on \mouseout  mouseout

  # highlight from graph
  node-group
    .on \mouseover mouseover
    .on \mouseout  mouseout

  # highlight from layout
  rectangles
    .on \mouseover mouseover
    .on \mouseout  mouseout
  lines
    .on \mouseover mouseover
    .on \mouseout  mouseout

  # Testing: make move1 on expr
  tokens.on \click !->
    next = expr[it.postorder + 1]
    if
      # move 1
      it.operand and next?operand
        new-expr = move.0 expr, it, next

        layout = layout-from new-expr

        display-layout do
          layout
          layout-root
          rect-root
          line-root
          tree-root
          link-root
          node-root
          expr-root

      it.operator and it.parent?
        # if move 3 is possible, take it, else move2
        if next? and valid expr, it, next
          new-expr = move.2 expr, it, next
        else
          # for now, just complement as many as we can
          current = it.node
          len = 0
          for i from it.postorder + 1 til expr.length
            if expr[i]operator and expr[i]node is not current
              current = expr[i]node
              len++
            else
              break

          new-expr = move.1 expr, it.postorder, len

        layout = layout-from new-expr

        display-layout do
          layout
          layout-root
          rect-root
          line-root
          tree-root
          link-root
          node-root
          expr-root

# from postorder expr nodes to new tree
function layout-from expr
  expr.=slice()
  stack = [expr.shift!, expr.shift!]
  while next = expr.shift!
    if next.operator
      right = stack.pop!
      left = stack.pop!
      next.children = [left, right]
    stack.push next

  return stack.0

# SA moves, operating on slicing expression
move =
  # swap two adjacent operands (rectangles)
  * function move1 expr, rect1, rect2
      expr.slice!
        &[rect1.postorder] = rect2
        &[rect2.postorder] = rect1

  # complement some chain of non-zero length
  * function move2 expr, chain-start, len
      expr.slice!
        for i from chain-start to chain-start + len
          &[i]node = complement[<>]

  # swap two adjacent operand and operator
  # WARNING: doesn't check for validity of the move
  * function move3 expr, alpha1, alpha2
      expr.slice!
        &[alpha1.postorder] = alpha2
        &[alpha2.postorder] = alpha1

# whether a move3 is valid
# section 4, last paragraph in the paper
function valid expr, alpha1, alpha2
  alpha3 = expr[alpha2.postorder + 1]
  if alpha3? and alpha3.node is alpha1.node
    return false

  if alpha1.operand and alpha2.operator
    console.log alpha1.postorder
    console.log 2 * alpha2.d
    2 * alpha2.d < alpha1.postorder # 2d_(i-1) < i
  else
    true

# adapted from http://blog.pixelingene.com/2011/07/building-a-tree-diagram-in-d3-js/
<-! document.add-event-listener \DOMContentLoaded

layout-root = d3.select \#slicing-rectangle
  .append \svg:svg .attr width: 300 height: 300
  .append \svg:g .attr \class \layout-container

rect-root = layout-root
  .append \svg:g .attr \class \layout-rectangles

line-root = layout-root
  .append \svg:g .attr \class \layout-lines

expr-root = d3.select \#polish-expression .append \svg:svg

tree-root = d3.select \#slicing-tree
  .append \svg:svg .attr width: 500 height: 500
  .append \svg:g
    .attr do
      id        : \tree-root
      transform : 'translate(50, 50)'

link-root = tree-root
  .append \svg:g
  .attr do
    id: \link-root

node-root = tree-root
  .append \svg:g
  .attr do
    id: \node-root

chips =
  * width: 10 height: 10
  * width:  6 height: 12
  * width:  3 height:  2
  * width:  5 height:  3
  * width:  5 height:  3
  * width:  5 height:  3

layout = initial-layout chips

display-layout do
  layout
  layout-root
  rect-root
  line-root
  tree-root
  link-root
  node-root
  expr-root
