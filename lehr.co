# width, height
chips =
  * width: 10 height: 10
  * width:  5 height: 12
  * width:  3 height:  2
  * width:  5 height:  3
  * width:  8 height:  8
  * width:  3 height:  5
  * width:  6 height:  6
  * width:  1 height:  1

# per section 7 in the paper, start with horizontal layout, recursively
function initial-layout chips, n = 0
  node: \H
  children:
    * node: n
      width: chips.0.width * 10
      height: chips.0.height * 10
      chip: chips.0
    * if chips.length is 2
        node:   n + 1
        width:  chips.1.width * 10
        height: chips.1.height * 10
        chip: chips.1
      else
        initial-layout chips.slice(1), n + 1

slicing-layout = initial-layout chips

# mix it up a little
op = H: \V V: \H
init = slicing-layout.node
current = slicing-layout
while current = current.children?1
  init = op[init]
  current.node = init unless current.node is not \H and current.node is not \V

SVGL = -> document.createElementNS \http://www.w3.org/2000/svg it

width = height = 500

slice-direction = H: \width, V: \height
opposite = width: \height height: \width
line-dimension = width: \x height: \y
opp-dimension = x: \y y: \x

# expand leaves to rectangles, and decorate branch nodes with size fitted to
# their children
function calculate-size layout
  if layout.children?
    left  = calculate-size layout.children.0
    right = calculate-size layout.children.1

    dir = slice-direction[layout.node]
    opp = opposite[dir]

    fitted = Math.max left[dir], right[dir]

    # expand both children
    set-size left,  dir, fitted
    set-size right, dir, fitted

    # fitted along slice direction, summed in other
    layout <<<
      (dir): fitted
      (opp): left[opp] + right[opp]
  else
    layout

function set-size layout, dir, value
  layout[dir] = value
  if slice-direction[layout.node] is dir and layout.children
    set-size that.0, dir, value
    set-size that.1, dir, value

slicing-layout = calculate-size slicing-layout

console.log slicing-layout

function slicing-rectangle ({children}: layout, position = x: 0, y: 0)
  SVGL \svg
    &setAttribute \class "layout-slice layout-slice-#{layout.node}"

    &setAttribute \width layout.width
    &setAttribute \height layout.height

    &setAttribute \x position.x
    &setAttribute \y position.y

    if children?
      [left, right] = children

      dir = slice-direction[layout.node]
      opp = opposite[dir]

      line-dim = line-dimension[dir]
      line-opp = opp-dimension[line-dim]

      left-rect  = slicing-rectangle left
      right-rect = slicing-rectangle right,
                                     (line-dim): 0
                                     (line-opp): left[opp]

      &appendChild left-rect
      &appendChild right-rect

      &appendChild with SVGL \line
        &setAttribute \class "layout-line layout-line-#{layout.node}"
        &setAttribute \id "l#{layout.preorder}"

        # stretches across group
        &setAttribute line-dim + \1 0
        &setAttribute line-dim + \2 layout[dir]

        # starting after left node
        &setAttribute line-opp + \1 left[opp]
        &setAttribute line-opp + \2 left[opp]
    else
      &appendChild with SVGL \rect
        &setAttribute \id "l#{layout.preorder}"
        &setAttribute \class \layout-rect
        &setAttribute \width \100%
        &setAttribute \height \100%
      &appendChild with SVGL \rect
        &setAttribute \id "chip#{layout.node}"
        &setAttribute \class \chip-rect
        &setAttribute \width layout.chip.width
        &setAttribute \height layout.chip.height

        # center within bounds
        &setAttribute \x layout.width / 2 - layout.chip.width # TODO
        &setAttribute \y layout.chip.height

      &appendChild with SVGL \text
        &setAttribute \class \layout-text
        &setAttribute \x layout.width / 2
        &setAttribute \y layout.height / 2
        &textContent = layout.node

# postorder walk
expr = []
visit = ->
  if it.children then for that => visit &
  expr.push it

visit slicing-layout

# decorate postorder index
for n, i of expr
  n.postorder = i

tree = d3.layout.tree!size [400 400]
nodes = tree.nodes slicing-layout
links = tree.links nodes

# nodes is preordered, so assign index for lookup
# TODO is there a better way to do this
for n, i of nodes
  n.preorder = i

# adapted from http://blog.pixelingene.com/2011/07/building-a-tree-diagram-in-d3-js/
<-! document.add-event-listener \DOMContentLoaded

document.getElementById \slicing-rectangle
  .appendChild slicing-rectangle slicing-layout

layout-root = d3.select \#slicing-tree
  .append \svg:svg .attr width: 500 height: 500
  .append \svg:g
    .attr do
      class     : \container
      transform : 'translate(50, 50)'

link = d3.svg.diagonal!

layout-root.select-all \path.link
  .data links .enter!
  .append \svg:path
  .attr do
    class : \link
    d     : link

node-group = layout-root.select-all \g.node
  .data nodes .enter!
  .append \svg:g
  .attr do
    class     : \node
    transform : ({x, y}) -> "translate(#x, #y)"

circles = node-group.append \svg:circle
  .attr do
    class : \node-dot
    r     : 20

node-group.append \svg:text
  .attr class: \node-text
  .text -> it.node

# draw polish expr
expr-root = d3.select \#polish-expression .append \p

highlight = (it, className, state)->
  d3.select tokens.0[it.postorder] .classed className, state
  d3.select circles.0[it.preorder] .classed className, state
  d3.select "\#l#{it.preorder}"    .classed className, state

# highlight node and its left and right subtree in both the tree and expression
set-class = (state) -> ->
  highlight it, \hovered state
  if it.children
    highlight-tree that.0, \left-hovered state
    highlight-tree that.1, \right-hovered state

highlight-tree = (root, className, state) ->
  highlight root, className, state
  if root.children
    highlight-tree that.0, className, state
    highlight-tree that.1, className, state

mouseover = set-class true
mouseout = set-class false

tokens = expr-root.select-all \span.token
  .data expr .enter!
  .append \span
    .attr class: \token
    .text -> it.node
    .on \mouseover mouseover
    .on \mouseout  mouseout

# highlight tokens from graph
node-group
  .on \mouseover mouseover
  .on \mouseout  mouseout

for n, i of nodes
  let el = document.get-element-by-id "l#{n.preorder}"
    el.add-event-listener \mouseover ->
      mouseover.call this, n
    el.add-event-listener \mouseout ->
      mouseout.call this, n

